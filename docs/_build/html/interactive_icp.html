

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Interactive Iterative Closest Point &mdash; PCL DOCUMENTATION 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: dark blue" >
          

          
            <a href="index.html" class="icon icon-home"> PCL DOCUMENTATION
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="walkthrough.html">1. PCL Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_structures.html">2. Getting Started / Basic Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_pcl_pcl_config.html">3. Using PCL in your own project</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_posix.html">4. Compiling PCL from source on POSIX compliant systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_pcl.html">5. Customizing the PCL build process</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_dependencies_windows.html">6. Building PCL’s dependencies from source on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_windows.html">7. Compiling PCL from source on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_macosx.html">8. Compiling PCL and its dependencies from MacPorts and source on Mac OS X</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing_homebrew.html">9. Installing on Mac OS X using Homebrew</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_pcl_with_eclipse.html">10. Using PCL with Eclipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="generate_local_doc.html">11. Generate a local documentation for PCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_transform.html">12. Using a matrix to transform a point cloud</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="adding_custom_ptype.html">1. Adding your own custom <cite>PointT</cite> type</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_new_classes.html">2. Writing a new PCL class</a></li>
</ul>
<p class="caption"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="how_features_work.html">1. How 3D Features work in PCL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PCL DOCUMENTATION</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Interactive Iterative Closest Point</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/interactive_icp.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="interactive-iterative-closest-point">
<span id="interactive-icp"></span><h1><a class="toc-backref" href="#id1">Interactive Iterative Closest Point</a><a class="headerlink" href="#interactive-iterative-closest-point" title="Permalink to this headline">¶</a></h1>
<p>This tutorial will teach you how to write an interactive ICP viewer. The program will
load a point cloud and apply a rigid transformation on it. After that the ICP algorithm will
align the transformed point cloud with the original. Each time the user presses “space”
an ICP iteration is done and the viewer is refreshed.</p>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#interactive-iterative-closest-point" id="id1">Interactive Iterative Closest Point</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-a-mesh-with-blender" id="id2">Creating a mesh with Blender</a></p></li>
<li><p><a class="reference internal" href="#the-code" id="id3">The code</a></p></li>
<li><p><a class="reference internal" href="#the-explanations" id="id4">The explanations</a></p></li>
<li><p><a class="reference internal" href="#compiling-and-running-the-program" id="id5">Compiling and running the program</a></p></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="creating-a-mesh-with-blender">
<h2><a class="toc-backref" href="#id2">Creating a mesh with Blender</a><a class="headerlink" href="#creating-a-mesh-with-blender" title="Permalink to this headline">¶</a></h2>
<p>You can easily create a sample point cloud with Blender.
Install and open Blender then delete the cube in the scene by pressing “Del” key :</p>
<a class="reference internal image-reference" href="_images/del_cube.png"><img alt="_images/del_cube.png" src="_images/del_cube.png" style="height: 285px;" /></a>
<p>Add a monkey mesh in the scene :</p>
<a class="reference internal image-reference" href="_images/add_monkey.png"><img alt="_images/add_monkey.png" src="_images/add_monkey.png" style="height: 328px;" /></a>
<p>Subdivide the original mesh to make it more dense :</p>
<a class="reference internal image-reference" href="_images/add_sub.png"><img alt="_images/add_sub.png" src="_images/add_sub.png" style="height: 500px;" /></a>
<p>Configure the subdivision to 2 or 3 for example : don’t forget to apply the modifier</p>
<a class="reference internal image-reference" href="_images/sub2.png"><img alt="_images/sub2.png" src="_images/sub2.png" style="height: 203px;" /></a>
<p>Export the mesh into a PLY file :</p>
<a class="reference internal image-reference" href="_images/export.png"><img alt="_images/export.png" src="_images/export.png" style="height: 481px;" /></a>
</div>
<div class="section" id="the-code">
<h2><a class="toc-backref" href="#id3">The code</a><a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h2>
<p>First, create a file, let’s say, <code class="docutils literal notranslate"><span class="pre">interactive_icp.cpp</span></code> in your favorite
editor, and place the following code inside it:</p>
</div>
<div class="section" id="the-explanations">
<h2><a class="toc-backref" href="#id4">The explanations</a><a class="headerlink" href="#the-explanations" title="Permalink to this headline">¶</a></h2>
<p>Now, let’s break down the code piece by piece.</p>
<p>We include all the headers we will make use of.
<strong>#include &lt;pcl/registration/ia_ransac.h&gt;</strong> allows us to use <strong>pcl::transformPointCloud</strong> function.
<strong>#include &lt;pcl/console/parse.h&gt;&gt;</strong> allows us to use parse the arguments given to the program.</p>
<p>Two typedefs to simplify declarations and code reading.
The bool will help us know when the user asks for the next iteration of ICP</p>
<p>This function takes the reference of a 4x4 matrix and prints the rigid transformation in an human
readable way.</p>
<p>This function is the callback for the viewer. This function will be called whenever a key is pressed
when the viewer window is on top. If “space” is hit; set the bool to true.</p>
<p>The 3 point clouds we will use to store the data.</p>
<p>We check the arguments of the program, set the number of initial ICP iterations
and try to load the PLY file.</p>
<p>We transform the original point cloud using a rigid matrix transformation.
See the related tutorial in PCL documentation for more information.
<strong>cloud_in</strong> contains the original point cloud.
<strong>cloud_tr</strong> and <strong>cloud_icp</strong> contains the translated/rotated point cloud.
<strong>cloud_tr</strong> is a backup we will use for display (green point cloud).</p>
<p>This is the creation of the ICP object. We set the parameters of the ICP algorithm.
<strong>setMaximumIterations(iterations)</strong> sets the number of initial iterations to do (1
is the default value). We then transform the point cloud into <strong>cloud_icp</strong>.
After the first alignment we set ICP max iterations to 1 for all the next times this
ICP object will be used (when the user presses “space”).</p>
<p>Check if the ICP algorithm converged; otherwise exit the program.
In case of success we store the transformation matrix in a 4x4 matrix and
then print the rigid matrix transformation. The reason why we store this
matrix is explained later.</p>
<p>For the visualization we create two viewports in the visualizer vertically
separated. <strong>bckgr_gray_level</strong> and <strong>txt_gray_lvl</strong> are variables to easily
switch from white background &amp; black text/point cloud to black background &amp;
white text/point cloud.</p>
<p>We add the original point cloud in the 2 viewports and display it the same color
as <strong>txt_gray_lvl</strong>. We add the point cloud we transformed using the matrix in the left
viewport in green and the point cloud aligned with ICP in red (right viewport).</p>
<p>We add descriptions for the point clouds in each viewport so the user knows what is what.
The string stream ss is needed to transform the integer <strong>iterations</strong> into a string.</p>
<p>We set the two viewports background color according to <strong>bckgr_gray_level</strong>.
To get the camera parameters I simply pressed “C” in the viewer. Then I copied the
parameters into this function to save the camera position / orientation / focal point.
The function <strong>registerKeyboardCallback</strong> allows us to call a function whenever the
users pressed a keyboard key when viewer windows is on top.</p>
<p>This is the normal behaviour if no key is pressed. The viewer waits to exit.</p>
<p>If the user press any key of the keyboard, the function <strong>keyboardEventOccurred</strong> is called;
this function checks if the key is “space” or not. If yes the global bool <strong>next_iteration</strong>
is set to true, allowing the viewer loop to enter the next part of the code: the ICP object
is called to align the meshes. Remember we already configured this object input/output clouds
and we set max iterations to 1 in lines 90-93.</p>
<p>As before we check if ICP as converged, if not we exit the program.
<strong>printf(“033[11A”);</strong> is a little trick to go up 11 lines in the terminal to write
over the last matrix displayed. In short it allows to replace text instead of writing
new lines; making the output more readable.
We increment <strong>iterations</strong> to update the text value in the visualizer.</p>
<p>Now we want to display the rigid transformation from the original transformed point cloud to
the current alignment made by ICP. The function <strong>getFinalTransformation()</strong> returns the rigid
matrix transformation done during the iterations (here: 1 iteration). This means that if you have already
done 10 iterations this function returns the matrix to transform the point cloud from the iteration 10 to 11.</p>
<p>This is not what we want. If we multiply the last matrix with the new one the result is the transformation matrix from
the start to the current iteration. This is basically how it works</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">matrix</span><span class="p">[</span><span class="n">ICP</span> <span class="mi">0</span><span class="o">-&gt;</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">matrix</span><span class="p">[</span><span class="n">ICP</span> <span class="mi">1</span><span class="o">-&gt;</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">matrix</span><span class="p">[</span><span class="n">ICP</span> <span class="mi">2</span><span class="o">-&gt;</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">ICP</span> <span class="mi">0</span><span class="o">-&gt;</span><span class="mi">3</span><span class="p">]</span>
</pre></div>
</div>
<p>While this is mathematically true, you will easily notice that this is not true in this program due to roundings.
This is why I introduced the initial ICP iteration parameters. Try to launch the program with 20 initial iterations
and save the matrix in a text file. Launch the same program with 1 initial iteration and press space till you go to 20
iterations. You will a notice a slight difference. The matrix with 20 initial iterations is much more accurate than the
one multiplied 19 times.</p>
<p>We set the bool to false and the rest is the ending of the program.</p>
</div>
<div class="section" id="compiling-and-running-the-program">
<h2><a class="toc-backref" href="#id5">Compiling and running the program</a><a class="headerlink" href="#compiling-and-running-the-program" title="Permalink to this headline">¶</a></h2>
<p>Add the following lines to your CMakeLists.txt file:</p>
<p>After you have made the executable, you can run it. Simply do:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./interactive_icp monkey.ply 1
</pre></div>
</div>
<p>Remember that the matrix displayed is not very accurate if you do a lot of iterations
by pressing “space”.</p>
<p>You will see something similar to this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./interactive_icp ../monkey.ply 5
[pcl::PLYReader] ../monkey.ply:12: property &#39;list uint8 uint32 vertex_indices&#39; of element &#39;face&#39; is not handled

Loaded file ../monkey.ply (125952 points) in 578 ms

Applying this rigid transformation to: cloud_in -&gt; cloud_icp
Rotation matrix :
    |  0.924 -0.383  0.000 |
R = |  0.383  0.924  0.000 |
    |  0.000  0.000  1.000 |
Translation vector :
t = &lt;  0.000,  0.000,  0.400 &gt;

Applied 1 ICP iteration(s) in 2109 ms

ICP has converged, score is 0.0182442

ICP transformation 1 : cloud_icp -&gt; cloud_in
Rotation matrix :
    |  0.998  0.066 -0.003 |
R = | -0.066  0.997  0.033 |
    |  0.005 -0.033  0.999 |
Translation vector :
t = &lt;  0.022, -0.017, -0.097 &gt;
</pre></div>
</div>
<p>If ICP did a perfect job the two matrices should have exactly the same values and
the matrix found by ICP should have inverted signs outside the diagonal. For example</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>    <span class="o">|</span>  <span class="mf">0.924</span> <span class="o">-</span><span class="mf">0.383</span>  <span class="mf">0.000</span> <span class="o">|</span>
<span class="n">R</span> <span class="o">=</span> <span class="o">|</span>  <span class="mf">0.383</span>  <span class="mf">0.924</span>  <span class="mf">0.000</span> <span class="o">|</span>
    <span class="o">|</span>  <span class="mf">0.000</span>  <span class="mf">0.000</span>  <span class="mf">1.000</span> <span class="o">|</span>
<span class="n">Translation</span> <span class="n">vector</span> <span class="p">:</span>
<span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span>  <span class="mf">0.000</span><span class="p">,</span>  <span class="mf">0.000</span><span class="p">,</span>  <span class="mf">0.400</span> <span class="o">&gt;</span>

    <span class="o">|</span>  <span class="mf">0.924</span>  <span class="mf">0.383</span>  <span class="mf">0.000</span> <span class="o">|</span>
<span class="n">R</span> <span class="o">=</span> <span class="o">|</span> <span class="o">-</span><span class="mf">0.383</span>  <span class="mf">0.924</span>  <span class="mf">0.000</span> <span class="o">|</span>
    <span class="o">|</span>  <span class="mf">0.000</span>  <span class="mf">0.000</span>  <span class="mf">1.000</span> <span class="o">|</span>
<span class="n">Translation</span> <span class="n">vector</span> <span class="p">:</span>
<span class="n">t</span> <span class="o">=</span> <span class="o">&lt;</span>  <span class="mf">0.000</span><span class="p">,</span>  <span class="mf">0.000</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.400</span> <span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>If you iterate several times manually using “space”; the results will become more and more erroned because
of the matrix multiplication (see line 181 of the original code)
If you seek precision, provide an initial number of iterations to the program</p>
</div>
<a class="reference internal image-reference" href="_images/icp-1.png"><img alt="_images/icp-1.png" src="_images/icp-1.png" style="height: 605px;" /></a>
<p>After 25 iterations the models fits perfectly the original cloud. Remember that this is an easy job for ICP because
you are asking to align two identical point clouds !</p>
<a class="reference internal image-reference" href="_images/animation.gif"><img alt="_images/animation.gif" src="_images/animation.gif" style="height: 630px;" /></a>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Arzoo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>