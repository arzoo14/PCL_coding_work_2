

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>PCLVisualizer &mdash; PCL DOCUMENTATION 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: dark blue" >
          

          
            <a href="index.html" class="icon icon-home"> PCL DOCUMENTATION
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="walkthrough.html">1. PCL Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_structures.html">2. Getting Started / Basic Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_pcl_pcl_config.html">3. Using PCL in your own project</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_posix.html">4. Compiling PCL from source on POSIX compliant systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_pcl.html">5. Customizing the PCL build process</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_dependencies_windows.html">6. Building PCL’s dependencies from source on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_windows.html">7. Compiling PCL from source on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_macosx.html">8. Compiling PCL and its dependencies from MacPorts and source on Mac OS X</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing_homebrew.html">9. Installing on Mac OS X using Homebrew</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_pcl_with_eclipse.html">10. Using PCL with Eclipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="generate_local_doc.html">11. Generate a local documentation for PCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_transform.html">12. Using a matrix to transform a point cloud</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="adding_custom_ptype.html">1. Adding your own custom <cite>PointT</cite> type</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_new_classes.html">2. Writing a new PCL class</a></li>
</ul>
<p class="caption"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="how_features_work.html">1. How 3D Features work in PCL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PCL DOCUMENTATION</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>PCLVisualizer</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/pcl_visualizer.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="pclvisualizer">
<span id="pcl-visualizer"></span><h1>PCLVisualizer<a class="headerlink" href="#pclvisualizer" title="Permalink to this headline">¶</a></h1>
<p>PCLVisualizer is PCL’s full-featured visualisation class. While more
complex to use than the CloudViewer, it is also more powerful, offering
features such as displaying normals, drawing shapes and multiple
viewports.</p>
<p>This tutorial will use a code sample to illustrate some of the features
of PCLVisualizer, beginning with displaying a single point cloud. Most
of the code sample is boilerplate to set up the point clouds that will
be visualised. The relevant code for each sample is contained in a
function specific to that sample. The code is shown below. Copy it into
a file named <code class="docutils literal notranslate"><span class="pre">pcl_visualizer_demo.cpp</span></code>.</p>
<div class="section" id="compiling-and-running-the-program">
<h2>Compiling and running the program<a class="headerlink" href="#compiling-and-running-the-program" title="Permalink to this headline">¶</a></h2>
<p>Create a <cite>CMakeLists.txt</cite> file with the following contents:</p>
<p>After you have made the executable, you can run it like so:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ ./pcl_visualizer_demo -h
</pre></div>
</div>
<p>Change the option to change which demo is executed. See the help output
for details.</p>
<p>To exit the viewer application, press <code class="docutils literal notranslate"><span class="pre">q</span></code>. Press <code class="docutils literal notranslate"><span class="pre">r</span></code> to centre and
zoom the viewer so that the entire cloud is visible. Use the mouse to
rotate the viewpoint by clicking and dragging. You can use the scroll
wheel, or right-click and drag up and down, to zoom in and out.
Middle-clicking and dragging will move the camera.</p>
</div>
</div>
<div class="section" id="visualising-a-single-cloud">
<h1>Visualising a single cloud<a class="headerlink" href="#visualising-a-single-cloud" title="Permalink to this headline">¶</a></h1>
<p>This sample uses PCLVisualizer to display a single PointXYZ cloud. It
also illustrates changing the background colour and displaying the axes.
The code is in the function <code class="docutils literal notranslate"><span class="pre">simpleVis</span></code>.</p>
<a class="reference internal image-reference" href="_images/pcl_visualizer_simple.png"><img alt="_images/pcl_visualizer_simple.png" src="_images/pcl_visualizer_simple.png" style="width: 838px;" /></a>
<div class="section" id="explanation">
<h2>Explanation<a class="headerlink" href="#explanation" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">simpleVis</span></code> function shows how to perform the most basic
visualisation of a point cloud. Let’s take a look at the function,
line-by-line.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">viewer</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span> <span class="p">(</span><span class="s">&quot;3D Viewer&quot;</span><span class="p">));</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This creates the viewer object, giving it a nice name to display in the
title bar. We are storing it in a smart pointer only so it can be
passed around the demo program. Usually, you do not need to do this.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setBackgroundColor</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The background colour of the viewer can be set to any RGB colour you
like. In this case, we are setting it to black.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="s">&quot;sample cloud&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This is the most important line. We add the point cloud to the viewer,
giving it an ID string that can be used to identify the cloud in other
methods. Multiple point clouds can be added with multiple calls to
<code class="docutils literal notranslate"><span class="pre">addPointCloud()</span></code>, supplying a new ID each time. If you want to update
a point cloud that is already displayed, you must first call
<code class="docutils literal notranslate"><span class="pre">removePointCloud()</span></code> and provide the ID of the cloud that is to be
updated. (Note: versions 1.1 and up of PCL provide a new API method,
<code class="docutils literal notranslate"><span class="pre">updatePointCloud()</span></code>, that allows a cloud to be updated without
manually calling <code class="docutils literal notranslate"><span class="pre">removePointCloud()</span></code> first.)</p>
<p>This is the most basic of <code class="docutils literal notranslate"><span class="pre">addPointCloud()</span></code>’s many
variations. Others are used to handle different point types, display
normals, and so on. We will illustrate some others during this tutorial,
or you can see the <a class="reference external" href="http://docs.pointclouds.org/1.0.0/classpcl_1_1visualization_1_1_p_c_l_visualizer.html">PCLVisualizer documentation</a> for more details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;sample cloud&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This next line changes the size of the rendered points. You can control
the way any point cloud is rendered in the viewer using this method.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addCoordinateSystem</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Viewing complex point clouds can often be disorientating. To keep
yourself aligned in the world, axes can be displayed. These will appear
as three cylinders along the X (red), Y (green) and Z (blue) axes. The
size of the cylinders can be controlled using the <code class="docutils literal notranslate"><span class="pre">scale</span></code> parameter.
In this case, we have set it to 1.0 (which also happens to be the
default if no value is given). An alternative version of this method can
be used to place the axes at any point in the world.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">initCameraParameters</span> <span class="p">();</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This final call sets up some handy camera parameters to make things look
nice.</p>
<p>There is one final piece of code relevant to all the samples. It can be
found at the bottom of the sample:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">viewer</span><span class="o">-&gt;</span><span class="n">wasStopped</span> <span class="p">())</span>
<span class="p">{</span>
  <span class="n">viewer</span><span class="o">-&gt;</span><span class="n">spinOnce</span> <span class="p">(</span><span class="mi">100</span><span class="p">);</span>
  <span class="n">boost</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">sleep</span> <span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">posix_time</span><span class="o">::</span><span class="n">microseconds</span> <span class="p">(</span><span class="mi">100000</span><span class="p">));</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>These lines are running an event loop. Each call to <code class="docutils literal notranslate"><span class="pre">spinOnce</span></code> gives
the viewer time to process events, allowing it to be interactive. There
is also a <code class="docutils literal notranslate"><span class="pre">spin</span></code> method, which only needs to be called once.</p>
</div>
</div>
<div class="section" id="adding-some-colour">
<h1>Adding some colour<a class="headerlink" href="#adding-some-colour" title="Permalink to this headline">¶</a></h1>
<p>Often, a point cloud will not use the simple PointXYZ type. One common
point type is PointXYZRGB, which also contains colour data. Aside from
that, you may wish to colour specific point clouds to make them
distinguishable in the viewer. PCLVizualizer provides facilities for
displaying point clouds with the colour data stored within them, or for
assigning colours to point clouds.</p>
<div class="section" id="rgb-point-clouds">
<h2>RGB point clouds<a class="headerlink" href="#rgb-point-clouds" title="Permalink to this headline">¶</a></h2>
<p>Many devices, such as the Microsoft Kinect, produce point clouds with
RGB data. PCLVisualizer can display the cloud using this data to colour
each point. The code in the <code class="docutils literal notranslate"><span class="pre">rgbVis</span></code> function shows how to do this.</p>
<a class="reference internal image-reference" href="_images/pcl_visualizer_color_rgb.png"><img alt="_images/pcl_visualizer_color_rgb.png" src="_images/pcl_visualizer_color_rgb.png" style="width: 838px;" /></a>
</div>
<div class="section" id="id1">
<h2>Explanation<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>Not much of the code in this sample has changed from the earlier sample.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">rgbVis</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;::</span><span class="n">ConstPtr</span> <span class="n">cloud</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
<p>First, notice that the point type has changed from the simple example.
We now use a point type that also provides room for RGB data. This is
important; without the RGB fields in the point (the point type does not
necessarily have to be <code class="docutils literal notranslate"><span class="pre">PointXYZRGB</span></code>, as long as it has the three
colour fields), PCLVisualizer would not know what colours to use.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerRGB</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="n">rgb</span><span class="p">(</span><span class="n">point_cloud_ptr</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Next, after setting the viewer’s background colour, we create a colour
handler object. PCLVisualizer uses objects like this to display custom
data. In this case, the object will get the RGB colour fields from each
point for the viewer to use when drawing them. Many other handlers exist
for a wide range of purposes. We will see another of the colour handlers
in the next code sample, but handlers also exist for such purposes as
drawing any other field as the colour and drawing geometry from point
clouds. See the <a class="reference external" href="http://docs.pointclouds.org/1.0.0/group__visualization.html">documentation</a> for details.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">rgb</span><span class="p">,</span> <span class="s">&quot;sample cloud&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Finally, when we add the point cloud, we specify the colour handler when
we add the point cloud to the viewer.</p>
</div>
<div class="section" id="custom-colours">
<h2>Custom colours<a class="headerlink" href="#custom-colours" title="Permalink to this headline">¶</a></h2>
<p>The second code sample demonstrates giving a point cloud a single
colour. We can use this technique to give specific point clouds their
own colours, allowing us to distinguish individual point clouds. In this
sample, given in the <code class="docutils literal notranslate"><span class="pre">customColourVis</span></code> function, we have set the point
cloud’s colour to green. (We have also increased the size of the points
to make the colour more visible.)</p>
<a class="reference internal image-reference" href="_images/pcl_visualizer_color_custom.png"><img alt="_images/pcl_visualizer_color_custom.png" src="_images/pcl_visualizer_color_custom.png" style="width: 838px;" /></a>
</div>
<div class="section" id="id2">
<h2>Explanation<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Again, not much of the code in this sample has changed from the earlier
sample.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">customColourVis</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;::</span><span class="n">ConstPtr</span> <span class="n">cloud</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The point type in use this time is back to PointXYZ again. When setting
a custom colour handler for a point cloud, it doesn’t matter what the
underlying data type is. None of the point fields are used for the
colour with the custom colour handler.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerCustom</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="n">single_color</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>We create a custom colour handler and assign it a nice, bright shade of
green.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZ</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">single_color</span><span class="p">,</span> <span class="s">&quot;sample cloud&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As with the previous example, we pass the colour handler in when we call
<code class="docutils literal notranslate"><span class="pre">addPointCloud&lt;&gt;()</span></code>.</p>
</div>
</div>
<div class="section" id="normals-and-other-information">
<h1>Normals and other information<a class="headerlink" href="#normals-and-other-information" title="Permalink to this headline">¶</a></h1>
<p>Displaying normals is an important step in understanding a point cloud.
The PCLVisualizer class has the ability to draw normals, as well as
other interesting point cloud information, such as principal curvatures
and geometries.</p>
<p>The code sample in the <code class="docutils literal notranslate"><span class="pre">normalsVis</span></code> function shows how to display the
normals of a point cloud. The code for calculating the normals will not
be explained in this tutorial. See the normals calculation tutorial for
details.</p>
<a class="reference internal image-reference" href="_images/pcl_visualizer_normals.png"><img alt="_images/pcl_visualizer_normals.png" src="_images/pcl_visualizer_normals.png" style="width: 838px;" /></a>
<div class="section" id="id3">
<h2>Explanation<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>The relevant line of code is placed after the line to draw the point
cloud.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloudNormals</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Normal</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="s">&quot;normals&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Once you have your normals, one extra line is all it takes to display
them in the viewer. The parameters to this method set the number of
normals to display (here, every tenth normal is displayed) and the
length of the line to draw for each normal (0.05, in this case).</p>
</div>
</div>
<div class="section" id="drawing-shapes">
<h1>Drawing Shapes<a class="headerlink" href="#drawing-shapes" title="Permalink to this headline">¶</a></h1>
<p>PCLVisualizer allows you to draw various primitive shapes in the view.
This is often used to visualise the results of point cloud processing
algorithms, for example, visualising which clusters of points have been
recognised as landmarks by drawing transparent spheres around them.</p>
<p>The sample code in the <code class="docutils literal notranslate"><span class="pre">shapesVis</span></code> function illustrates some of the
methods used to add shapes to a viewer. It adds four shapes:</p>
<ul class="simple">
<li><p>A line from the first point in the cloud to the last point in the
cloud.</p></li>
<li><p>A plane at the origin.</p></li>
<li><p>A sphere centred on the first point in the cloud.</p></li>
<li><p>A cone along the Y-axis.</p></li>
</ul>
<a class="reference internal image-reference" href="_images/pcl_visualizer_shapes.png"><img alt="_images/pcl_visualizer_shapes.png" src="_images/pcl_visualizer_shapes.png" style="width: 838px;" /></a>
<div class="section" id="id4">
<h2>Explanation<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>The relevant parts of the code sample for drawing shapes begin after the
point cloud is added to the viewer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addLine</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cloud</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">[</span><span class="n">cloud</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="s">&quot;line&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This line (of code) adds a line (in space) from the first point in the
cloud to the last point. This method is useful, for example, for showing
correspondences between point clouds. In this case, the line is using
the default colour, but you can also specify the colour of the line.
Drawing shapes at points from a point cloud is very common, and various
shapes are available.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addSphere</span> <span class="p">(</span><span class="n">cloud</span><span class="o">-&gt;</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="s">&quot;sphere&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This next line adds a sphere centred on the first point in the cloud
with a radius of 0.2. It also gives the sphere a colour.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">ModelCoefficients</span> <span class="n">coeffs</span><span class="p">;</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPlane</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="s">&quot;plane&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Next, we add a plane to the drawing. In this case, we are specifying the
plane using the standard plane equation (ax + by + cz + d = 0). Our
plane will be centered at the origin and oriented along the Z-axis. Many
of the shape drawing functions take coefficients in this way.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.3</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">0.0</span><span class="p">);</span>
<span class="n">coeffs</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addCone</span> <span class="p">(</span><span class="n">coeffs</span><span class="p">,</span> <span class="s">&quot;cone&quot;</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Finally, we add a cone. We are again using model coefficients to specify
the cone’s parameters.</p>
</div>
</div>
<div class="section" id="multiple-viewports">
<h1>Multiple viewports<a class="headerlink" href="#multiple-viewports" title="Permalink to this headline">¶</a></h1>
<p>You will often want to compare multiple point clouds side-by-side. While
you could draw them in the same view port, this can get confusing.
PCLVisualizer allows you to draw multiple point clouds in separate
viewports, making comparison easy.</p>
<p>The code in the <code class="docutils literal notranslate"><span class="pre">viewportsVis</span></code> function uses viewports to demonstrate
comparing the normals calculated for a point cloud. Two sets of normals
are calculated for the same cloud but using a different search radius.
The first time, the search radius is 0.05. The second time, it is 0.1.
The normals for the 0.05 radius search are displayed in the viewport
with the black background. The normals for the 0.1 radius search are
displayed in the viewport with the grey background.</p>
<p>Comparing the two sets of normals side-by-side makes it immediately
obvious what the effects of the different algorithm parameter are. In
this way, you can experiment with the parameters for algorithms to find
good settings, quickly viewing the results.</p>
<a class="reference internal image-reference" href="_images/pcl_visualizer_viewports.png"><img alt="_images/pcl_visualizer_viewports.png" src="_images/pcl_visualizer_viewports.png" style="width: 838px;" /></a>
<div class="section" id="id5">
<h2>Explanation<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">viewer</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span> <span class="p">(</span><span class="s">&quot;3D Viewer&quot;</span><span class="p">));</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">initCameraParameters</span> <span class="p">();</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This is our standard code for creating a viewer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="kt">int</span> <span class="n">v1</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">createViewPort</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setBackgroundColor</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addText</span> <span class="p">(</span><span class="s">&quot;Radius: 0.01&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot;v1 text&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerRGBField</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="n">rgb</span> <span class="p">(</span><span class="n">cloud</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">rgb</span><span class="p">,</span> <span class="s">&quot;sample cloud1&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The next step is to create a new viewport. The four parameters are the
minimum and maximum ranges of the viewport on the X- and Y-axes, between
0 and 1. We are creating a viewport that will fill the left half of the
window. We must store the view port ID number that is passed back in the
fifth parameter and use it in all other calls where we only want to
affect that viewport.</p>
<p>We also set the background colour of this viewport, give it a label
based on what we are using the viewport to distinguish, and add our
point cloud to it, using an RGB colour handler.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="kt">int</span> <span class="n">v2</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">createViewPort</span> <span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setBackgroundColor</span> <span class="p">(</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addText</span> <span class="p">(</span><span class="s">&quot;Radius: 0.1&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="s">&quot;v2 text&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PointCloudColorHandlerCustom</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="n">single_color</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">255</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloud</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">single_color</span><span class="p">,</span> <span class="s">&quot;sample cloud2&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Then we do the same thing again for the second viewport, making it take
up the right half of the window. We make this viewport a shade of grey
so it is easily distinguishable in the demonstration program. We add the
same point cloud, but this time we give it a custom colour handler.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;sample cloud1&quot;</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">setPointCloudRenderingProperties</span> <span class="p">(</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCL_VISUALIZER_POINT_SIZE</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">&quot;sample cloud2&quot;</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addCoordinateSystem</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>These three lines set some properties globally for all viewports. Most of
the PCLVisualizer methods accept an optional viewport ID parameter. When
it is specified, they affect only that viewport. When it is not, as in
this case, they affect all viewports.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloudNormals</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Normal</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">normals1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="s">&quot;normals1&quot;</span><span class="p">,</span> <span class="n">v1</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addPointCloudNormals</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">PointXYZRGB</span><span class="p">,</span> <span class="n">pcl</span><span class="o">::</span><span class="n">Normal</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">cloud</span><span class="p">,</span> <span class="n">normals2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="s">&quot;normals2&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Finally, we add the normals, one to each viewport.</p>
</div>
</div>
<div class="section" id="interaction-customization">
<h1>Interaction Customization<a class="headerlink" href="#interaction-customization" title="Permalink to this headline">¶</a></h1>
<p>You will sometimes feel that the interactivity options offered by the default
mouse and key bindings do not satisfy your needs and you may want to extend
functionality with features such as the possibility of saving the currently
shown point clouds when pressing a button or annotating certain locations on the
rendering window with your mouse etc. A very simple example of such things
is found in the <code class="docutils literal notranslate"><span class="pre">interactionCustomizationVis</span></code> method.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Mac platforms and if using a VTK version prior to 7.0, the executable is required to be built as an Application Bundle, in order to have proper mouse and keyboard interaction support. For more instructions on how to do that, please consult the <a class="reference external" href="http://www.vtk.org/Wiki/Cocoa_VTK#Use_Application_Bundles">Cocoa VTK Wiki</a>.</p>
</div>
<p>In this part of the tutorial you will be shown how to catch mouse and keyboard
events. By right clicking on the window, a 2D text will appear and you can
erase all the text instances by pressing ‘r’. The result should look something
like this:</p>
<a class="reference internal image-reference" href="_images/pcl_visualizer_interaction_customization.png"><img alt="_images/pcl_visualizer_interaction_customization.png" src="_images/pcl_visualizer_interaction_customization.png" style="width: 838px;" /></a>
<div class="section" id="id6">
<h2>Explanation<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">viewer</span> <span class="p">(</span><span class="k">new</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span> <span class="p">(</span><span class="s">&quot;3D Viewer&quot;</span><span class="p">));</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">initCameraParameters</span> <span class="p">();</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This is the standard code for instantiating a viewer.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">registerKeyboardCallback</span> <span class="p">(</span><span class="n">keyboardEventOccurred</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">viewer</span><span class="p">);</span>
<span class="n">viewer</span><span class="o">-&gt;</span><span class="n">registerMouseCallback</span> <span class="p">(</span><span class="n">mouseEventOccurred</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">viewer</span><span class="p">);</span>
<span class="p">...</span>
</pre></div>
</div>
<p>These two lines of code will register the two methods, <code class="docutils literal notranslate"><span class="pre">keyboardEventOccurred</span></code>
and <code class="docutils literal notranslate"><span class="pre">mouseEventOccurred</span></code> to the keyboard and mouse event callback, respectively.
The second arguments for the two method calls are the so-called cookies. These
are any parameters you might want to pass to the callback function. In our case,
we want to pass the viewer itself, in order to do modifications on it in case
of user interaction. Note that these arguments must be in the form of a single
<code class="docutils literal notranslate"><span class="pre">void*</span></code> instance, so we need to cast the pointer to our smart pointer to <code class="docutils literal notranslate"><span class="pre">void*</span></code>.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="kt">void</span> <span class="n">mouseEventOccurred</span> <span class="p">(</span><span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">MouseEvent</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span>
                     <span class="kt">void</span><span class="o">*</span> <span class="n">viewer_void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">viewer</span> <span class="o">=</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="n">viewer_void</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">getButton</span> <span class="p">()</span> <span class="o">==</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">MouseEvent</span><span class="o">::</span><span class="n">LeftButton</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="p">.</span><span class="n">getType</span> <span class="p">()</span> <span class="o">==</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">MouseEvent</span><span class="o">::</span><span class="n">MouseButtonRelease</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Left mouse button released at position (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">event</span><span class="p">.</span><span class="n">getX</span> <span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">event</span><span class="p">.</span><span class="n">getY</span> <span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>

    <span class="n">sprintf</span> <span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;text#%03d&quot;</span><span class="p">,</span> <span class="n">text_id</span> <span class="o">++</span><span class="p">);</span>
    <span class="n">viewer</span><span class="o">-&gt;</span><span class="n">addText</span> <span class="p">(</span><span class="s">&quot;clicked here&quot;</span><span class="p">,</span> <span class="n">event</span><span class="p">.</span><span class="n">getX</span> <span class="p">(),</span> <span class="n">event</span><span class="p">.</span><span class="n">getY</span> <span class="p">(),</span> <span class="n">str</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>This is the method that handles the mouse events. Every time any kind of mouse
event is registered, this function will be called. In order to see exactly what
that event is, we need to extract that information from the <code class="docutils literal notranslate"><span class="pre">event</span></code> instance.
In our case, we are looking for left mouse button releases. Whenever such an event
happens, we shall write a small text at the position of the mouse click.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">...</span>
<span class="kt">void</span> <span class="n">keyboardEventOccurred</span> <span class="p">(</span><span class="k">const</span> <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">KeyboardEvent</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">,</span>
                        <span class="kt">void</span><span class="o">*</span> <span class="n">viewer_void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="n">viewer</span> <span class="o">=</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">pcl</span><span class="o">::</span><span class="n">visualization</span><span class="o">::</span><span class="n">PCLVisualizer</span><span class="o">::</span><span class="n">Ptr</span> <span class="o">*&gt;</span> <span class="p">(</span><span class="n">viewer_void</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">getKeySym</span> <span class="p">()</span> <span class="o">==</span> <span class="s">&quot;r&quot;</span> <span class="o">&amp;&amp;</span> <span class="n">event</span><span class="p">.</span><span class="n">keyDown</span> <span class="p">())</span>
  <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;r was pressed =&gt; removing all text&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">text_id</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
      <span class="n">sprintf</span> <span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;text#%03d&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">viewer</span><span class="o">-&gt;</span><span class="n">removeShape</span> <span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">text_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The same approach applies for the keyboard events. We check what key was pressed
and the action we do is to remove all the text created by our mouse clicks.
Please note that when ‘r’ is pressed, the 3D camera still resets, as per
the original binding of ‘r’ inside PCLVisualizer. So, our keyboard events do not
overwrite the functionality of the base class.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Arzoo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>