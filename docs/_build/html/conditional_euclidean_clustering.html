

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Conditional Euclidean Clustering &mdash; PCL DOCUMENTATION 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: dark blue" >
          

          
            <a href="index.html" class="icon icon-home"> PCL DOCUMENTATION
          

          
          </a>

          
            
            
              <div class="version">
                0.0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="walkthrough.html">1. PCL Walkthrough</a></li>
<li class="toctree-l1"><a class="reference internal" href="basic_structures.html">2. Getting Started / Basic Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_pcl_pcl_config.html">3. Using PCL in your own project</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_posix.html">4. Compiling PCL from source on POSIX compliant systems</a></li>
<li class="toctree-l1"><a class="reference internal" href="building_pcl.html">5. Customizing the PCL build process</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_dependencies_windows.html">6. Building PCL’s dependencies from source on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_windows.html">7. Compiling PCL from source on Windows</a></li>
<li class="toctree-l1"><a class="reference internal" href="compiling_pcl_macosx.html">8. Compiling PCL and its dependencies from MacPorts and source on Mac OS X</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing_homebrew.html">9. Installing on Mac OS X using Homebrew</a></li>
<li class="toctree-l1"><a class="reference internal" href="using_pcl_with_eclipse.html">10. Using PCL with Eclipse</a></li>
<li class="toctree-l1"><a class="reference internal" href="generate_local_doc.html">11. Generate a local documentation for PCL</a></li>
<li class="toctree-l1"><a class="reference internal" href="matrix_transform.html">12. Using a matrix to transform a point cloud</a></li>
</ul>
<p class="caption"><span class="caption-text">Advanced Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="adding_custom_ptype.html">1. Adding your own custom <cite>PointT</cite> type</a></li>
<li class="toctree-l1"><a class="reference internal" href="writing_new_classes.html">2. Writing a new PCL class</a></li>
</ul>
<p class="caption"><span class="caption-text">Features</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="how_features_work.html">1. How 3D Features work in PCL</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PCL DOCUMENTATION</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Conditional Euclidean Clustering</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/conditional_euclidean_clustering.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="conditional-euclidean-clustering">
<span id="id1"></span><h1>Conditional Euclidean Clustering<a class="headerlink" href="#conditional-euclidean-clustering" title="Permalink to this headline">¶</a></h1>
<p>This tutorial describes how to use the <code class="docutils literal notranslate"><span class="pre">pcl::ConditionalEuclideanClustering</span></code> class:
A segmentation algorithm that clusters points based on Euclidean distance and a user-customizable condition that needs to hold.</p>
<p>This class uses the same greedy-like / region-growing / flood-filling approach that is used in <a class="reference internal" href="cluster_extraction.html#cluster-extraction"><span class="std std-ref">Euclidean Cluster Extraction</span></a>, <a class="reference internal" href="region_growing_segmentation.html#region-growing-segmentation"><span class="std std-ref">Region growing segmentation</span></a> and <a class="reference internal" href="region_growing_rgb_segmentation.html#region-growing-rgb-segmentation"><span class="std std-ref">Color-based region growing segmentation</span></a>.
The advantage of using this class over the other classes is that the constraints for clustering (pure Euclidean, smoothness, RGB) are now customizable by the user.
Some disadvantages include: no initial seeding system, no over- and under-segmentation control, and the fact that calling a conditional function from inside the main computational loop is less time efficient.</p>
</div>
<div class="section" id="theoretical-primer">
<h1>Theoretical Primer<a class="headerlink" href="#theoretical-primer" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="cluster_extraction.html#cluster-extraction"><span class="std std-ref">Euclidean Cluster Extraction</span></a> and <a class="reference internal" href="region_growing_segmentation.html#region-growing-segmentation"><span class="std std-ref">Region growing segmentation</span></a> tutorials already explain the region growing algorithm very accurately.
The only addition to those explanations is that the condition that needs to hold for a neighbor to be merged into the current cluster, can now be fully customized.</p>
<p>As a cluster grows, it will evaluate the user-defined condition between points already inside the cluster and nearby candidate points.
The candidate points (nearest neighbor points) are found using a Euclidean radius search around each point in the cluster.
For each point within a resulting cluster, the condition needed to hold with at least one of its neighbors and NOT with all of its neighbors.</p>
<p>The Conditional Euclidean Clustering class can also automatically filter clusters based on a size constraint.
The clusters classified as too small or too large can still be retrieved afterwards.</p>
</div>
<div class="section" id="the-code">
<h1>The Code<a class="headerlink" href="#the-code" title="Permalink to this headline">¶</a></h1>
<p>First, download the dataset <a class="reference external" href="https://sourceforge.net/projects/pointclouds/files/PCDdatasets/Trimble/Outdoor1/Statues_4.pcd.zip">Statues_4.pcd</a> and extract the PCD file from the archive.
This is a very large data set of an outdoor environment where we aim to cluster the separate objects and also want to separate the building from the ground plane even though it is attached in a Euclidean sense.</p>
<p>Now create a file, let’s say, <code class="docutils literal notranslate"><span class="pre">conditional_euclidean_clustering.cpp</span></code> in your favorite editor, and place the following inside it:</p>
</div>
<div class="section" id="the-explanation">
<h1>The Explanation<a class="headerlink" href="#the-explanation" title="Permalink to this headline">¶</a></h1>
<p>Since the Conditional Euclidean Clustering class is for more advanced users, I will skip explanation of the more obvious parts of the code:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pcl::io::loadPCDFile</span></code> and <code class="docutils literal notranslate"><span class="pre">pcl::io::savePCDFile</span></code> are used for loading and saving the point cloud data.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pcl::console::TicToc</span></code> is used for easy output of timing results.</p></li>
<li><p><a class="reference internal" href="voxel_grid.html#voxelgrid"><span class="std std-ref">Downsampling a PointCloud using a VoxelGrid filter</span></a> is being used (lines 66-73) to downsample the cloud and give a more equalized point density.</p></li>
<li><p><a class="reference internal" href="normal_estimation.html#normal-estimation"><span class="std std-ref">Estimating Surface Normals in a PointCloud</span></a> is being used (lines 75-83)  to estimate normals which will be appended to the point information;
The Conditional Euclidean Clustering class will be templated with <code class="docutils literal notranslate"><span class="pre">pcl::PoitnXYZINormal</span></code>, containing x, y, z, intensity, normal and curvature information to use in the condition function.</p></li>
</ul>
</div></blockquote>
<p>Lines 85-95 set up the Conditional Euclidean Clustering class for use:</p>
<p>A more elaborate description of the different lines of code:</p>
<blockquote>
<div><ul class="simple">
<li><p>The class is initialized with TRUE.
This will allow extraction of clusters that are too small or too large.
It saves some computation time and memory if the class is initialized without this.</p></li>
<li><p>The input data for the class can be specified using methods derived from the <code class="docutils literal notranslate"><span class="pre">PCLBase</span></code> class, i.e.: <code class="docutils literal notranslate"><span class="pre">setInputCloud</span></code> and <code class="docutils literal notranslate"><span class="pre">setIndices</span></code>.</p></li>
<li><p>As a cluster grows, it will evaluate a user-defined condition between points already inside the cluster and nearby candidate points.
More on the condition function can be read further below.</p></li>
<li><p>The cluster tolerance is the radius for the k-NN searching, used to find the candidate points.</p></li>
<li><p>Clusters that make up less than 0.1% of the cloud’s total points are considered too small.</p></li>
<li><p>Clusters that make up more than 20% of the cloud’s total points are considered too large.</p></li>
<li><p>The resulting clusters are stored in the <code class="docutils literal notranslate"><span class="pre">pcl::IndicesClusters</span></code> format, which is an array of indices-arrays, indexing points of the input point cloud.</p></li>
<li><p>Too small clusters or too large clusters are not passed to the main output but can instead be retrieved in separate <code class="docutils literal notranslate"><span class="pre">pcl::IndicesClusters</span></code> data containers, but only is the class was initialized with TRUE.</p></li>
</ul>
</div></blockquote>
<p>Lines 12-49 show some examples of condition functions:</p>
<p>The format of the condition function is fixed:</p>
<blockquote>
<div><ul class="simple">
<li><p>The first two input arguments need to be of the same type as the templated type used in the Conditional Euclidean Clustering class.
These arguments will pass the point information for the current seed point (first argument) and the current candidate point (second argument).</p></li>
<li><p>The third input argument needs to be a float.
This argument will pass the squared distance between the seed and candidate point.
Although this information is also computable using the first two arguments, it is already provided by the underlying nearest neighbor search and can be used to easily make a distance dependent condition function.</p></li>
<li><p>The output argument needs to be a boolean.
Returning TRUE will merge the candidate point into the cluster of the seed point.
Returning FALSE will not merge the candidate point through this particular point-pair, however, it is still possible that the two points will end up in the same cluster through a different point-pair relationship.</p></li>
</ul>
</div></blockquote>
<p>These example condition functions are just to give an indication of how to use them.
For instance, the second condition function will grow clusters as long as they are similar in surface normal direction OR similar in intensity value.
This should hopefully cluster buildings of similar texture as one cluster, but not merge them into the same cluster as adjacent objects.
This is going to work out if the intensity is different enough from nearby objects AND the nearby objects are not sharing a nearby surface with the same normal.
The third condition function is similar to the second but has different constraints depending on the distance between the points.</p>
<p>Lines 97-109 contain a piece of code that is a quick and dirty fix to visualize the result:</p>
<p>When the output point cloud is opened with PCL’s standard PCD viewer, pressing ‘5’ will switch to the intensity channel visualization.
The too-small clusters will be colored red, the too-large clusters will be colored blue, and the actual clusters/objects of interest will be colored randomly in between yellow and cyan hues.</p>
</div>
<div class="section" id="compiling-and-running-the-program">
<h1>Compiling and running the program<a class="headerlink" href="#compiling-and-running-the-program" title="Permalink to this headline">¶</a></h1>
<p>Add the following lines to your CMakeLists.txt</p>
<p>After you have made the executable, you can run it. Simply do:</p>
<blockquote>
<div><p>$ ./conditional_euclidean_clustering</p>
</div></blockquote>
<p>The resulting output point cloud can be opened like so:</p>
<blockquote>
<div><p>$ ./pcl_viewer output.pcd</p>
</div></blockquote>
<p>You should see something similar to this:</p>
<img alt="Output Cluster Extraction" class="align-center" src="_images/conditional_euclidean_clustering.jpg" />
<p>This result is sub-optimal but it gives an idea of what can be achieved with this class.
The mathematics and heuristics behind the customizable condition are now the responsibility of the user.</p>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Arzoo

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
    <!-- Theme Analytics -->
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-XXXXXXX-1', 'auto');
    ga('send', 'pageview');
    </script>

    
   

</body>
</html>